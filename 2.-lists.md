# 2. Lists

## Bits <a href="#the-mystery-of-the-walrus" id="the-mystery-of-the-walrus"></a>

æ‰€æœ‰çš„ä¿¡æ¯åœ¨ç”µè„‘é‡Œé€šè¿‡0å’Œ1å‚¨å­˜åœ¨å†…å­˜é‡Œã€‚æœ‰è¶£çš„äº‹72å’ŒHéƒ½ä¿å­˜æˆ01001000ã€‚ç”µè„‘æ€ä¹ˆåŒºåˆ«å¥¹ä»¬çš„å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯é€šè¿‡ç±»å‹ã€‚

```java
char c = 'H';
int x = c;
System.out.println(c);
System.out.println(x);
```

x å’Œ c å˜é‡åŒ…å«ç›¸åŒçš„bitsï¼Œä½†æ˜¯java å¯¹å¾…å¥¹ä»¬ç¡®ä¸åŒ

primitive types: byte, short, int, long, float, double, boolean, char

## Declaring a Variable

å¯ä»¥æƒ³è±¡ç”µè„‘é‡Œä¸ºäº†å­˜å‚¨ä¿¡æ¯åŒ…æ‹¬å¤§é‡çš„bitsï¼Œæ¯ä¸ªmemory bit æœ‰å¥½ä¸€ä¸ªå”¯ä¸€çš„åœ°å€ã€‚

å½“å£°æ˜ä¸€ä¸ªå…·ä½“ç±»å‹çš„å˜é‡ï¼ŒJava finds a contiguous block with exactly enough bits to hold a thing of that typeã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ declare ä¸€ä¸ªintï¼Œå¾—åˆ°ä¸€ä¸ª32bitsçš„å—ï¼Œå¦‚æœdeclareä¸€ä¸ªbyteï¼Œå¾—åˆ°ä¸€ä¸ª8bitsçš„å—ã€‚æ¯ä¸ªæ•°æ®ç±»å‹éƒ½æœ‰ä¸åŒæ•°é‡çš„bitsã€‚ç§°ä¸ºbox of bitsã€‚

é™¤äº†memory, java è§£é‡Šå™¨ä¹Ÿåˆ›å»ºä¸€ä¸ªentryåœ¨å†…è¡¨é‡Œï¼Œæ¯ä¸ªå˜é‡çš„åç§°å¯¹åº”boxçš„ç¬¬ä¸€ä¸ªbitçš„ä½ç½®ï¼Œ

&#x20;ä¾‹å¦‚ï¼Œå£°æ˜ `int x` å’Œ `double y` , java å†³å®šç”¨å†…å­˜ä»352åˆ°384æ¥å­˜å‚¨xï¼Œä»bit 20800åˆ°20864æ¥å­˜å‚¨yã€‚ç„¶åinterpreter è®°å½•int x ä»bit 352å¼€å§‹ï¼Œyä»bit 20800å¼€å§‹

javaéšè—memory locationsã€‚java æ²¡æœ‰default valuesï¼Œæ‰€ä»¥é™¤éä½¿ç”¨=ï¼Œ javaä¼šé˜»æ­¢ä¸è®©ä½¿ç”¨å˜é‡ã€‚

## The Golden Rule of Equals (GRoE)

This simple idea of copying the bits is true for ANY assignment using `=` in Java.

<figure><img src=".gitbook/assets/WeChat99e587efb618aff5c93b67b4d583fcee.jpg" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/WeChatffa17d69a7e35423f591818f4539765f.jpg" alt=""><figcaption></figcaption></figure>

## Reference Types

Reference ç±»å‹

å½“æˆ‘ä»¬ç”¨ `new` è¦å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡, java é¦–å…ˆåˆ†é…ä¸€ä¸ªbox ç»™ç±»é‡Œçš„æ¯ä¸€ä¸ªå®ä¾‹å˜é‡ï¼Œç„¶åé€šè¿‡default valueå¡«å……è¿™äº›å®ä¾‹å˜é‡ã€‚ Constructor å¾€å¾€å¡«å……è¿™äº›boxé€šè¿‡ä¸€äº›ç‰¹å®šçš„å€¼ã€‚

ä¾‹å¦‚ï¼Œ

```java
public static class Walrus {
    public int weight;
    public double tuckSize;
    
    public Walrus(int w, double ts) {
        weight = w;
        tuckSize = ts;
    }
}
```

æˆ‘ä»¬é€šè¿‡ `new Walrus(1000, 8.3)` åˆ›å»ºä¸€ä¸ªWalrusï¼Œ WalrusåŒ…å«ä¸¤ä¸ªboxï¼Œåˆ†åˆ«æ˜¯32bits å’Œ  64bitsã€‚

<figure><img src=".gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

## Reference Variable Declaration

å½“æˆ‘ä»¬å£°æ˜ç±»å‹æ˜¯referenceçš„å˜é‡ï¼Œjava åˆ†é…ä¸€ä¸ª64bitsçš„boxï¼Œä¸ç®¡å¯¹è±¡æ˜¯ä»€ä¹ˆã€‚è¿™64bitsåŒ…æ‹¬çš„ä¸æ˜¯å†…å®¹ï¼Œæ˜¯åœ¨memory é‡Œçš„åœ°å€ã€‚

```java
Walrus someWalrus;
someWalrus = new Walrus(1000, 8.3);
```

ç¬¬ä¸€è¡Œæ˜¯åˆ›å»ºä¸€ä¸ª64bitsçš„boxï¼Œç¬¬äºŒè¡Œæ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„`Walrus`ï¼Œåœ°å€é€šè¿‡ `new` æ¥è¿”å›ã€‚è¿™äº›bitså†å¤åˆ¶è¿› `someWalrus` boxã€‚

## Box and Pointer Notation

æ‰€ä»¥ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªsimplified box for reference variable

* å¦‚æœä¸€ä¸ªåœ°å€å…¨æ˜¯0ï¼Œ æˆ‘ä»¬å°†ç”¨nullè¡¨ç¤ºã€‚
* ä¸€ä¸ªéé›¶åœ°å€å¯ä»¥è¡¨ç¤ºä¸€ä¸ªç®­å¤´æŒ‡å‘å¯¹è±¡å®ä¾‹

ç§°ä¸º"box and pointer"ã€‚

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

## Resolving the Mystery of the Walrus

```java
Walrus a = new Walrus(1000, 8.3);
Walrus b;
b = a;
```

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

## Parameter Passing

å½“pass å‚æ•°åˆ°functionï¼Œæˆ‘ä»¬ä¹Ÿæ˜¯å¤åˆ¶bitsã€‚æ¢å¥è¯è¯´ï¼ŒGROEä¹Ÿåº”ç”¨åˆ°å‚æ•°ä¼ é€’ã€‚ å¤åˆ¶bitsä¹Ÿå«åšpass by value (ä¼ å€¼)ã€‚

ä¾‹å¦‚ï¼Œ

```java
public static double average(double a, double b) {
    return (a + b) / 2;
}
```



## Instantiation of Arrays

java array is fixed size.



## InLists

```java
public class IntList {
    public int first;
    public IntList rest;
    
    /** Return the size of the list using  recursion */
    public int size() {
        //first need a base case for recursion
        if (rest = null) {
            return 1;
        }
        return 1 + this.rest.size();
    
    }
    /** Return the sie of list using no recursion*/
    public int iterativeSize() {
        IntList p = this;
        int totalsize = 0;
        while (p != null) {
            totalsize += 1;
            p = p.rest;
        }
        return totalsize;
    }

    public IntList(int f, IntList r) {
        first = f;
        rest = r;
    }
    
    public static void main(String[] args) {
        IntList L = new IntList(15, null);
        L = new IntList(10, L);
        L = new IntList(5, L);
    }
}

```

å»ºè®®ç”¨pæé†’è‡ªå·±ï¼Œå˜é‡hold a pointerã€‚å¾ˆéœ€è¦pï¼Œå› ä¸ºä¸èƒ½é‡æ–°é…ç½®thisã€‚



## SLLists

IntList çš„

```java
public class IntNode {
    public int item;
    public IntNode next;
    
    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

IntNode X = new IntNode(10, null)

```java
public class SLList {
    public IntNode first;
    
    public SLList(int x) {
        front = new IntNode(x, null);
    }
    ...
}
```

SLList Y = new SLList(10)



åŠ addFirst, getFirst

```java
public class SLList {
    public IntNode first;
    
    public SLList(int x) {
        front = new IntNode(x, null);
    }
    /** Adds x to the front of the list*/
    public void addFirst(int x) {
        first = new IntNode(x, first)
    }
    /** Returns the first item in the list.*/
    public int getFirst() {
        return first.item
    }
    public static void main(String[], args) {
        SLList L = new SLList(10)
    }
}
```

<figure><img src=".gitbook/assets/Screenshot 2024-02-29 at 11.53.05â€¯am.png" alt=""><figcaption></figcaption></figure>

SLListçš„middle man æ˜¯ firstï¼Œæ€ä¹ˆæ“ä½œéƒ½ç»•ä¸å¼€è¿™ä¸ªmiddleman

ä¸€èˆ¬ä¼šprivate IntNode first; first å°±ä¸ä¼šè¢«æ”¹æˆå…¶ä»–çš„èµ·ç‚¹ï¼Œå¯¼è‡´ä»£ç é”™è¯¯

nested class : æŠŠä¸€ä¸ªclass æ”¾è¿›å¦ä¸€ä¸ªclass lim

static: å¯ç†è§£ä¸ºnever looks outwards

å¦‚æœIntNode æ”¹ä¸º static\`

```java
public class SLList {
    private static class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }
}
```

å¦‚æœçœŸçš„IntNodeæ²¡æœ‰ç”¨åˆ°SLListåˆ°ä»»ä½•å…¶ä»–çš„methods, å¯ä»¥è¿™ä¹ˆæ”¹ï¼ŒåŒæ—¶save memory&#x20;

```java
public void addLast(int x) {
    IntList p = first;
    /* move p util the end of list*/
    while (p.next != null) {
        p = p.next
    }
    p.next = new IntNode(x, null);
    
}
private static int size(IntNode p) {
    if (p.next == null) {
        return 1;
    }
    
    return 1 + size(p.next);
      
}
public int Size() {
    return size(first)
}
```

å¯¹äºä¸Šæ®µä»£ç çš„ç›¸å…³æ³¨é‡Šï¼špublic method speaks the language of mortalsã€‚ private method speaks the language of the gods. public method is middleman.

ä½†æ˜¯æ¯æ¬¡æ‰§è¡Œsizeçš„æ—¶å€™éƒ½æ˜¯å¾ªç¯æ“ä½œå¾ˆè´¹æ—¶é—´ã€‚æ‰€ä»¥å¢åŠ private int size; &#x20;



<figure><img src=".gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

THis object-oriented progamming approach means we let the object control everything. We tell the object your job is not only do all these tasks, but also to track the size for me.  ç¬¬äºŒä¸ªå›¾é‡Œï¼Œæ¡†èµ·æ¥çš„é‚£ä¸ªsizeå’Œfirstç›¸å½“äºobject, å½“ä½œmiddleman



å½“first is null çš„æ—¶å€™ï¼ŒaddLastä¸­çš„ p.next!= null æŠ¥é”™ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½è®©null p æ‰¾åˆ°ä¸‹ä¸€ä¸ªåœ°å€ã€‚è¿™æ—¶å€™å°±éœ€è¦sentinel node&#x20;





<figure><img src=".gitbook/assets/Screenshot 2024-02-29 at 2.05.43â€¯pm.png" alt=""><figcaption></figcaption></figure>

sentinel æ˜¯ä¸€ä¸ªğŸ’‚ï¼Œæˆ‘ä»¬å¯ä»¥ä¾é ä»–ä»¬ï¼Œä»–ä»¬æ°¸è¿œä¸ä¼šæ¶ˆå¤±ï¼Œåƒå¤§å±±å¤§æµ·ã€‚faithful companion

```java
public class SLList {
    private static class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }
    /** the first item(if it exists) is at sentinel.next*/
    private IntNode sentinel;
    private int size;
    
    public SLList() {
        sentinel = new IntNode(63,null);
        size = 0;
    }
}
```

sentinel åªèƒ½åœ¨ä¸€ä¸ªå”¯ä¸€çš„åœ°æ–¹ï¼Œå°±æ˜¯ç¬¬ä¸€ä¸ªä½ç½®ä¸Šï¼Œæˆ‘ä»¬ä¸èƒ½re-assigning setinelã€‚

å› æ­¤ï¼Œä¸èƒ½ `sentinel = new IntNode(x, sentinel); åªèƒ½æ˜¯ sentinel.next = new IntNode(x, sentinel.next);`

### DLList

our list has two links for every node.

list æ˜¯ç©ºçš„æ—¶å€™ï¼Œsentinel å’Œlast æŒ‡å‘ç›¸åŒçš„node

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

list size = 2 çš„æ—¶å€™

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

`last` pointer sometimes points at the sentinel node, and sometimes at a real node

ä¿®æ”¹æ–¹æ³•ï¼š

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

ä¿®æ”¹æ–¹æ³•2:

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

### Generic DLLists

<figure><img src=".gitbook/assets/Screenshot 2024-02-29 at 8.59.45â€¯pm.png" alt=""><figcaption></figcaption></figure>



<figure><img src=".gitbook/assets/Screenshot 2024-02-29 at 9.00.37â€¯pm.png" alt=""><figcaption></figcaption></figure>

## Array

<figure><img src=".gitbook/assets/Screenshot 2024-03-03 at 10.02.09â€¯am.png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/Screenshot 2024-03-03 at 10.02.50â€¯am.png" alt=""><figcaption></figcaption></figure>

in Java, all the boxes in array must be the same type.

arrays æ²¡æœ‰ methodsã€‚

3ç§æ–¹æ³•æ¥å®šä¹‰arrayï¼šï¼ˆ1ï¼‰x = new int\[3] (2) x = new int\[] {1, 2, 4} (3) int\[] w = {1,2,3};

Java åªæœ‰ä¹ä¸ªç±»å‹å¯ä»¥å­˜ï¼Œ8ä¸ªprimitive types and reference type. åœ°å€å±äºç¬¬äºŒä¸ªã€‚



## 2D array

int\[]\[] pascalsTriangle&#x20;

matrix = new int\[4]\[]

<figure><img src=".gitbook/assets/Screenshot 2024-03-03 at 10.56.25â€¯am.png" alt=""><figcaption></figcaption></figure>

matrix = new int\[4]\[4]

<figure><img src=".gitbook/assets/Screenshot 2024-03-03 at 10.57.17â€¯am.png" alt=""><figcaption></figcaption></figure>



















